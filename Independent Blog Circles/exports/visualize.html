<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Blog Network Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; }
        #container { width: 100vw; height: 100vh; }
        svg { width: 100%; height: 100%; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            max-width: 280px;
            z-index: 100;
            font-size: 13px;
        }
        #controls h3 { margin-bottom: 10px; color: #333; }
        #controls label { display: block; margin: 8px 0 4px; font-size: 12px; color: #666; }
        #controls select, #controls input { width: 100%; padding: 6px; margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px; }
        #stats { font-size: 12px; color: #666; margin: 10px 0; line-height: 1.6; }
        #legend { margin-top: 10px; font-size: 11px; }
        #legend div { display: flex; align-items: center; margin: 2px 0; }
        #legend span { width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; display: inline-block; }
        .btn { padding: 6px 12px; margin: 3px 3px 3px 0; cursor: pointer; border: none; border-radius: 4px; background: #4CAF50; color: white; font-size: 12px; }
        .btn:hover { background: #45a049; }
        .btn.secondary { background: #2196F3; }
        #tooltip {
            position: absolute;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
            max-width: 300px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
        }
        #tooltip a { color: #2196F3; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
        }
        .node { cursor: pointer; }
        .node:hover { stroke: white; stroke-width: 2px; }
        .link { stroke: #ffffff20; stroke-width: 0.5px; }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading 17k blogs...</div>
    </div>
    <div id="controls">
        <h3>Chinese Blog Network</h3>
        <div id="stats">Loading...</div>

        <label>Search:</label>
        <input type="text" id="searchInput" placeholder="Search by URL or name...">

        <label>Color by:</label>
        <select id="colorBy">
            <option value="ssg">SSG (Static Site Generator)</option>
            <option value="comment">Comment System</option>
        </select>

        <label>Filter SSG:</label>
        <select id="filterSSG">
            <option value="">All SSGs</option>
        </select>

        <label>Show top N nodes:</label>
        <select id="nodeLimit">
            <option value="500">500 nodes</option>
            <option value="1000">1,000 nodes</option>
            <option value="2000" selected>2,000 nodes</option>
            <option value="5000">5,000 nodes</option>
            <option value="all">All nodes (slow)</option>
        </select>

        <button class="btn" onclick="rerender()">Apply Filter</button>
        <button class="btn secondary" onclick="resetZoom()">Reset Zoom</button>

        <div id="legend"></div>
    </div>
    <div id="tooltip"></div>

    <script>
        const SSG_COLORS = {
            'hexo': '#0E83CD',
            'wordpress': '#21759B',
            'typecho': '#497E8E',
            'hugo': '#FF4088',
            'astro': '#FF5D01',
            'vitepress': '#42b883',
            'vuepress': '#42b883',
            'nextjs': '#ffffff',
            'nuxt': '#00DC82',
            'halo': '#4CCBA0',
            'jekyll': '#CC0000',
            'ghost': '#738A94',
            'gatsby': '#663399',
            'docusaurus': '#2E8555',
            'unknown': '#888888'
        };

        const COMMENT_COLORS = {
            'twikoo': '#4A90D9',
            'waline': '#FF6B6B',
            'valine': '#60B5FF',
            'giscus': '#238636',
            'gitalk': '#24292E',
            'disqus': '#2E9FFF',
            'utterances': '#0969DA',
            'artalk': '#FF7F50',
            'none': '#666666'
        };

        let allBlogs = [];
        let allEdges = [];
        let svg, g, zoom;
        let simulation;

        async function loadData() {
            try {
                // Load blogs
                const blogsResponse = await fetch('../data/blogs.jsonl');
                const blogsText = await blogsResponse.text();
                allBlogs = blogsText.trim().split('\n').map(line => {
                    try { return JSON.parse(line); } catch { return null; }
                }).filter(b => b && b.url);

                // Load edges
                const edgesResponse = await fetch('../data/edges.csv');
                const edgesText = await edgesResponse.text();
                const edgeLines = edgesText.trim().split('\n').slice(1);
                allEdges = edgeLines.map(line => {
                    const parts = line.split(',');
                    return { source: parts[0], target: parts[1], type: parts[2] };
                });

                // Calculate degrees
                const degreeMap = {};
                allEdges.forEach(e => {
                    degreeMap[e.source] = (degreeMap[e.source] || 0) + 1;
                    degreeMap[e.target] = (degreeMap[e.target] || 0) + 1;
                });
                allBlogs.forEach(b => {
                    b.degree = degreeMap[b.url] || 0;
                });

                // Sort by degree
                allBlogs.sort((a, b) => b.degree - a.degree);

                document.getElementById('loading').style.display = 'none';
                populateFilters();
                render();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').textContent = 'Error: ' + error.message;
            }
        }

        function populateFilters() {
            const ssgCounts = {};
            allBlogs.forEach(b => {
                const ssg = b.ssg || 'unknown';
                ssgCounts[ssg] = (ssgCounts[ssg] || 0) + 1;
            });

            const select = document.getElementById('filterSSG');
            Object.entries(ssgCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([ssg, count]) => {
                    const option = document.createElement('option');
                    option.value = ssg;
                    option.textContent = `${ssg} (${count})`;
                    select.appendChild(option);
                });
        }

        function render() {
            const container = document.getElementById('container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Clear existing
            d3.select('#container svg').remove();
            if (simulation) simulation.stop();

            // Filter data
            const filterSSG = document.getElementById('filterSSG').value;
            const searchQuery = document.getElementById('searchInput').value.toLowerCase();
            const limitValue = document.getElementById('nodeLimit').value;

            let filteredBlogs = allBlogs.filter(b => {
                if (filterSSG && (b.ssg || 'unknown') !== filterSSG) return false;
                if (searchQuery) {
                    const matchUrl = b.url.toLowerCase().includes(searchQuery);
                    const matchName = b.name && b.name.toLowerCase().includes(searchQuery);
                    if (!matchUrl && !matchName) return false;
                }
                return true;
            });

            // Limit nodes
            const limit = limitValue === 'all' ? filteredBlogs.length : parseInt(limitValue);
            filteredBlogs = filteredBlogs.slice(0, limit);

            const nodeUrls = new Set(filteredBlogs.map(b => b.url));
            const filteredEdges = allEdges.filter(e =>
                nodeUrls.has(e.source) && nodeUrls.has(e.target)
            );

            // Create node/link data
            const nodes = filteredBlogs.map(b => ({
                id: b.url,
                name: b.name || b.url,
                ssg: b.ssg || 'unknown',
                comment: b.comment_system?.type || 'none',
                degree: b.degree,
                url: b.url
            }));

            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            const links = filteredEdges
                .filter(e => nodeMap.has(e.source) && nodeMap.has(e.target))
                .map(e => ({ source: e.source, target: e.target }));

            // Update stats
            const colorBy = document.getElementById('colorBy').value;
            updateStats(nodes, links);
            updateLegend(nodes, colorBy);

            // Create SVG
            svg = d3.select('#container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            g = svg.append('g');

            // Zoom behavior
            zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => g.attr('transform', event.transform));
            svg.call(zoom);

            // Create simulation
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(30).strength(0.1))
                .force('charge', d3.forceManyBody().strength(-50))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => Math.sqrt(d.degree) + 3));

            // Draw links
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('class', 'link');

            // Draw nodes
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('class', 'node')
                .attr('r', d => Math.max(3, Math.min(15, 2 + Math.sqrt(d.degree))))
                .attr('fill', d => getColor(d, colorBy))
                .call(drag(simulation))
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip)
                .on('click', (event, d) => window.open(d.url, '_blank'));

            // Simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
            });
        }

        function getColor(node, colorBy) {
            if (colorBy === 'ssg') {
                return SSG_COLORS[node.ssg] || SSG_COLORS['unknown'];
            } else {
                return COMMENT_COLORS[node.comment] || COMMENT_COLORS['none'];
            }
        }

        function updateStats(nodes, links) {
            document.getElementById('stats').innerHTML = `
                <strong>${nodes.length.toLocaleString()}</strong> blogs shown<br>
                <strong>${links.length.toLocaleString()}</strong> connections<br>
                <strong>${allBlogs.length.toLocaleString()}</strong> total in dataset
            `;
        }

        function updateLegend(nodes, colorBy) {
            const colors = colorBy === 'ssg' ? SSG_COLORS : COMMENT_COLORS;
            const counts = {};
            nodes.forEach(n => {
                const val = colorBy === 'ssg' ? n.ssg : n.comment;
                counts[val] = (counts[val] || 0) + 1;
            });

            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]).slice(0, 8);
            document.getElementById('legend').innerHTML = '<strong>Legend:</strong>' +
                sorted.map(([key, count]) =>
                    `<div><span style="background:${colors[key] || '#888'}"></span>${key} (${count})</div>`
                ).join('');
        }

        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <strong>${d.name}</strong><br>
                <a href="${d.url}" target="_blank">${d.url}</a><br>
                SSG: ${d.ssg}<br>
                Comments: ${d.comment}<br>
                Connections: ${d.degree}
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function drag(simulation) {
            return d3.drag()
                .on('start', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on('drag', (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on('end', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                });
        }

        function rerender() {
            render();
        }

        function resetZoom() {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        }

        // Color change handler
        document.getElementById('colorBy').addEventListener('change', () => {
            const colorBy = document.getElementById('colorBy').value;
            d3.selectAll('.node').attr('fill', d => getColor(d, colorBy));
            // Recalculate legend with current nodes
            const nodes = d3.selectAll('.node').data();
            updateLegend(nodes, colorBy);
        });

        // Load on page ready
        loadData();
    </script>
</body>
</html>
